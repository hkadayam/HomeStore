native_include "utility/non_null_ptr.hpp";

namespace homestorecfg;

attribute "hotswap";
attribute "deprecated";

table BlkAllocator {
    max_cache_fill_varsize_blk_alloc_attempt: uint32 = 3 (hotswap); 
    max_varsize_blk_alloc_attempt: uint32 = 1000 (hotswap);
}

table Btree {
    max_nodes_to_rebalance: uint32 = 3; 

    mem_btree_page_size: uint32 = 8192;
}

table Cache {  
    /* Number of entries we ideally want to have per hash bucket. This number if small, will reduce contention and
     * speed of read/writes, but at the cost of increased memory */
    entries_per_hash_bucket: uint32 = 2;

    /* Number of eviction partitions. More the partitions better the parallelization of requests, but lesser the
     * effectiveness of cache, since it could get evicted sooner than expected, if distribution of key hashing is not
     * even.*/
    num_evictor_partitions: uint32 = 32;
}

table Device {
    max_error_before_marking_dev_down: uint32 = 100 (hotswap);

    // Outstanding IOs expected per thread. Exceeding this will result in io_submit failure
    max_outstanding_ios_per_aio_thread: uint32 = 200;

    // Max completions to process per event in a thread
    max_completions_process_per_event_per_thread: uint32 = 200;
}

table LogStore {
    // Size it needs to group upto before it flushes
    flush_threshold_size: uint64 = 512 (hotswap);

    // Time interval to wake up to check if flush is needed
    flush_timer_frequency_us: uint64 = 500 (hotswap);

    // Max time between 2 flushes. while it wakes up every flush timer, it checks if it needs to force a flush of
    // logs if it exceeds this limit
    max_time_between_flush_us: uint64 = 300 (hotswap);

    // Bulk read size to load during initial recovery
    bulk_read_size: uint64 = 524288 (hotswap);

    // How blks we need to read before confirming that we have not seen a corrupted block
    recovery_max_blks_read_for_additional_check: uint32 = 20;

    // Max size upto which data will be inlined instead of creating a separate value
    optimal_inline_data_size: uint64 = 512 (hotswap);
}

table Generic {

    /* Percentage of memory to be filled by app before we ask underlying mem allocator to free it up */
    soft_mem_release_threshold: uint32 = 85 (hotswap);

    /* Percentage of memory to be filled by app before we force underlying mem allocator to free it up */
    aggressive_mem_release_threshold: uint32 = 95 (hotswap);

    /* Rate of memory release rate to the underlying mem allocator */
    mem_release_rate: uint32 = 8;

    // blk alloc cp timer in us
    blkalloc_cp_timer_us: uint64 = 1000000 (hotswap);

    // writeback cache flush threads
    cache_flush_threads : int32 = 2;
}

table ResourceLimits {
    /* it is going to use 2 times of this space because of two concurrent cps */
    dirty_buf_percent: uint32 = 5 (hotswap);
    
    /* it is going to use 2 times of this space because of two concurrent cps */
    free_blk_cnt: uint32 = 1000000 (hotswap);
    free_blk_size: uint32 = 2 (hotswap);
    
    /* Percentage of memory allocated for homestore cache */
    cache_size_percent: uint32 = 65; 

    /* precentage of memory used during recovery */
    memory_in_recovery_precent: uint32 = 40;

    /* journal size used percentage */
    journal_size_percent: uint32 = 50;
}

table HomeStoreSettings {
    version: uint32 = 1;
    generic: Generic;
    blkallocator: BlkAllocator;
    cache: Cache;
    btree: Btree;
    device: Device;
    logstore: LogStore;
    resource_limits: ResourceLimits;
}

root_type HomeStoreSettings;
